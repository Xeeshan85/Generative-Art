<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractal Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 2.5em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-weight: bold;
            font-size: 0.9em;
            color: #e0e0e0;
        }
        
        select, input[type="range"] {
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
        }
        
        select {
            cursor: pointer;
        }
        
        select option {
            background: #2a5298;
            color: white;
        }
        
        input[type="range"] {
            height: 6px;
            background: rgba(255,255,255,0.3);
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        canvas {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            cursor: crosshair;
            background: black;
        }
        
        .info {
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .controls-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Interactive Fractal Explorer ðŸŒ€</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="fractalType">Fractal Type:</label>
                <select id="fractalType">
                    <option value="mandelbrot1">Mandelbrot z^1</option>
                    <option value="mandelbrot2">Mandelbrot z^2</option>
                    <option value="mandelbrot3">Mandelbrot z^3</option>
                    <option value="mandelbrot4">Mandelbrot z^4</option>
                    <option value="mandelbrot-2">Mandelbrot z^-2</option>
                    <option value="burningship">Burning Ship</option>
                    <option value="julia">Julia Set</option>
                    <option value="phoenix">Phoenix</option>
                    <option value="newton">Newton</option>
                    <option value="tricorn">Tricorn</option>
                    <option value="multibrot">Multibrot</option>
                    <option value="dragon">Dragon Curve</option>
                    <option value="spiral">Spiral Art</option>
                    <option value="rose">Rose Curve</option>
                    <option value="lissajous">Lissajous</option>
                    <option value="hypocycloid">Hypocycloid</option>
                    <option value="fermat">Fermat Spiral</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="iterations">Iterations: <span id="iterValue">100</span></label>
                <input type="range" id="iterations" min="50" max="500" value="100">
            </div>
            
            <div class="control-group">
                <label for="zoom">Zoom: <span id="zoomValue">100</span></label>
                <input type="range" id="zoom" min="10" max="1000" value="100">
            </div>
            
            <div class="control-group">
                <label for="colorScheme">Color Scheme:</label>
                <select id="colorScheme">
                    <option value="rainbow">Rainbow</option>
                    <option value="fire">Fire</option>
                    <option value="ocean">Ocean</option>
                    <option value="purple">Purple</option>
                    <option value="grayscale">Grayscale</option>
                </select>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="fractalCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="info">
            <p><strong>Controls:</strong></p>
            <div class="controls-info">
                <div><strong>W/S:</strong> Zoom In/Out</div>
                <div><strong>Arrow Keys:</strong> Navigate</div>
                <div><strong>Mouse:</strong> Click to center</div>
                <div><strong>Sliders:</strong> Auto-render on change</div>
            </div>
            <p id="coordinates">Center: (0, 0) | Zoom: 100x</p>
        </div>
    </div>
    
    <div class="loading" id="loading">Rendering fractal...</div>

    <script>
        class FractalRenderer {
            constructor() {
                this.canvas = document.getElementById('fractalCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Fractal parameters
                this.centerX = 0;
                this.centerY = 0;
                this.zoom = 100;
                this.maxIterations = 100;
                this.fractalType = 'mandelbrot2';
                this.colorScheme = 'rainbow';
                
                // Julia set parameters
                this.juliaReal = -0.7;
                this.juliaImag = 0.27015;
                
                this.setupEventListeners();
                this.render();
            }
            
            setupEventListeners() {
                // Control panel events
                document.getElementById('fractalType').addEventListener('change', () => {
                    this.fractalType = document.getElementById('fractalType').value;
                    this.render();
                });
                
                document.getElementById('iterations').addEventListener('input', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                    document.getElementById('iterValue').textContent = this.maxIterations;
                    this.render();
                });
                
                document.getElementById('zoom').addEventListener('input', (e) => {
                    this.zoom = parseInt(e.target.value);
                    document.getElementById('zoomValue').textContent = this.zoom;
                    this.render();
                });
                
                document.getElementById('colorScheme').addEventListener('change', () => {
                    this.colorScheme = document.getElementById('colorScheme').value;
                    this.render();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    const step = 1 / this.zoom;
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            this.zoom = Math.min(1000, this.zoom * 1.2);
                            document.getElementById('zoom').value = this.zoom;
                            document.getElementById('zoomValue').textContent = Math.round(this.zoom);
                            break;
                        case 's':
                            this.zoom = Math.max(10, this.zoom / 1.2);
                            document.getElementById('zoom').value = this.zoom;
                            document.getElementById('zoomValue').textContent = Math.round(this.zoom);
                            break;
                        case 'arrowup':
                            this.centerY -= step;
                            break;
                        case 'arrowdown':
                            this.centerY += step;
                            break;
                        case 'arrowleft':
                            this.centerX -= step;
                            break;
                        case 'arrowright':
                            this.centerX += step;
                            break;
                    }
                    this.render();
                    this.updateCoordinates();
                });
                
                // Mouse controls
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const realX = (x - this.width / 2) / this.zoom + this.centerX;
                    const realY = (y - this.height / 2) / this.zoom + this.centerY;
                    
                    this.centerX = realX;
                    this.centerY = realY;
                    this.render();
                    this.updateCoordinates();
                });
            }
            
            updateCoordinates() {
                document.getElementById('coordinates').textContent = 
                    `Center: (${this.centerX.toFixed(6)}, ${this.centerY.toFixed(6)}) | Zoom: ${Math.round(this.zoom)}x`;
            }
            
            getColor(iterations) {
                if (iterations === this.maxIterations) return [0, 0, 0];
                
                const t = iterations / this.maxIterations;
                
                switch(this.colorScheme) {
                    case 'rainbow':
                        return [
                            Math.floor(255 * Math.sin(t * Math.PI * 2) * 0.5 + 0.5),
                            Math.floor(255 * Math.sin(t * Math.PI * 2 + 2) * 0.5 + 0.5),
                            Math.floor(255 * Math.sin(t * Math.PI * 2 + 4) * 0.5 + 0.5)
                        ];
                    case 'fire':
                        return [
                            Math.floor(255 * t),
                            Math.floor(128 * t * t),
                            Math.floor(64 * t * t * t)
                        ];
                    case 'ocean':
                        return [
                            Math.floor(64 * t),
                            Math.floor(128 * t),
                            Math.floor(255 * t)
                        ];
                    case 'purple':
                        return [
                            Math.floor(128 + 127 * t),
                            Math.floor(64 * t),
                            Math.floor(255 * t)
                        ];
                    case 'grayscale':
                        const gray = Math.floor(255 * t);
                        return [gray, gray, gray];
                    default:
                        return [iterations * 3, iterations, iterations * 0.5];
                }
            }
            
            mandelbrot(cx, cy, power = 2) {
                let zx = 0, zy = 0;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 4) return i;
                    
                    if (power === 1) {
                        const temp = zx + cx;
                        zy = zy + cy;
                        zx = temp;
                    } else if (power === 2) {
                        const temp = zx * zx - zy * zy + cx;
                        zy = 2 * zx * zy + cy;
                        zx = temp;
                    } else if (power === 3) {
                        const temp = zx * zx * zx - 3 * zx * zy * zy + cx;
                        zy = 3 * zx * zx * zy - zy * zy * zy + cy;
                        zx = temp;
                    } else if (power === 4) {
                        const temp = zx * zx * zx * zx - 6 * zx * zx * zy * zy + zy * zy * zy * zy + cx;
                        zy = 4 * zx * zx * zx * zy - 4 * zx * zy * zy * zy + cy;
                        zx = temp;
                    } else if (power === -2) {
                        const denom = (zx * zx + zy * zy);
                        if (denom === 0) return i;
                        const temp = (zx * zx - zy * zy) / (denom * denom) + cx;
                        zy = -2 * zx * zy / (denom * denom) + cy;
                        zx = temp;
                    }
                }
                return this.maxIterations;
            }
            
            burningShip(cx, cy) {
                let zx = 0, zy = 0;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 4) return i;
                    
                    zx = Math.abs(zx);
                    zy = Math.abs(zy);
                    
                    const temp = zx * zx - zy * zy + cx;
                    zy = 2 * zx * zy + cy;
                    zx = temp;
                }
                return this.maxIterations;
            }
            
            julia(zx, zy) {
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 4) return i;
                    
                    const temp = zx * zx - zy * zy + this.juliaReal;
                    zy = 2 * zx * zy + this.juliaImag;
                    zx = temp;
                }
                return this.maxIterations;
            }
            
            phoenix(cx, cy) {
                let zx = 0, zy = 0;
                let px = 0, py = 0;
                const a = 0.56667, b = -0.5;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 16) return i;
                    
                    const tempX = zx * zx - zy * zy + a + b * px;
                    const tempY = 2 * zx * zy + b * py;
                    
                    px = zx;
                    py = zy;
                    zx = tempX + cx * 0.1;
                    zy = tempY + cy * 0.1;
                }
                return this.maxIterations;
            }
            
            newton(zx, zy) {
                for (let i = 0; i < this.maxIterations; i++) {
                    // Newton's method for z^3 - 1 = 0
                    const z3x = zx * zx * zx - 3 * zx * zy * zy;
                    const z3y = 3 * zx * zx * zy - zy * zy * zy;
                    
                    const denom = 9 * (zx * zx + zy * zy) * (zx * zx + zy * zy);
                    if (denom < 1e-10) return i;
                    
                    const newZx = zx - (z3x - 1) * 3 * (zx * zx + zy * zy) / denom;
                    const newZy = zy - z3y * 3 * (zx * zx + zy * zy) / denom;
                    
                    if (Math.abs(newZx - zx) + Math.abs(newZy - zy) < 1e-6) return i;
                    
                    zx = newZx;
                    zy = newZy;
                }
                return this.maxIterations;
            }
            
            tricorn(cx, cy) {
                let zx = 0, zy = 0;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 4) return i;
                    
                    const temp = zx * zx - zy * zy + cx;
                    zy = -2 * zx * zy + cy;
                    zx = temp;
                }
                return this.maxIterations;
            }
            
            multibrot(cx, cy) {
                let zx = 0, zy = 0;
                const d = 2.5;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    if (zx * zx + zy * zy > 4) return i;
                    
                    const r = Math.sqrt(zx * zx + zy * zy);
                    const theta = Math.atan2(zy, zx);
                    
                    const newR = Math.pow(r, d);
                    const newTheta = d * theta;
                    
                    zx = newR * Math.cos(newTheta) + cx;
                    zy = newR * Math.sin(newTheta) + cy;
                }
                return this.maxIterations;
            }
            
            dragon(x, y) {
                // Dragon curve approximation using iteration
                let px = x / this.zoom - this.centerX;
                let py = y / this.zoom - this.centerY;
                let result = 0;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    const r = Math.sqrt(px * px + py * py);
                    const angle = Math.atan2(py, px);
                    
                    px = r * Math.cos(angle * 2) * 0.8;
                    py = r * Math.sin(angle * 2) * 0.8;
                    
                    if (Math.abs(px) + Math.abs(py) > 2) {
                        result = i;
                        break;
                    }
                }
                return result;
            }
            
            spiral(x, y) {
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                const r = Math.sqrt(cx * cx + cy * cy);
                const theta = Math.atan2(cy, cx);
                
                // Archimedean spiral: r = a * theta
                const spiralR = 0.1 * theta;
                const diff = Math.abs(r - spiralR);
                
                return Math.floor(this.maxIterations * Math.exp(-diff * 10));
            }
            
            rose(x, y) {
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                const r = Math.sqrt(cx * cx + cy * cy);
                const theta = Math.atan2(cy, cx);
                
                // Rose curve: r = cos(k*theta)
                const k = 3; // Number of petals
                const roseR = Math.abs(Math.cos(k * theta));
                const diff = Math.abs(r - roseR);
                
                return Math.floor(this.maxIterations * Math.exp(-diff * 5));
            }
            
            lissajous(x, y) {
                const t = (x + y) / 100;
                const a = 3, b = 4; // Frequency ratios
                
                const lx = Math.sin(a * t);
                const ly = Math.sin(b * t);
                
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                const dist = Math.sqrt((cx - lx) * (cx - lx) + (cy - ly) * (cy - ly));
                return Math.floor(this.maxIterations * Math.exp(-dist * 10));
            }
            
            hypocycloid(x, y) {
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                const R = 2; // Large circle radius
                const r = 0.5; // Small circle radius
                const t = Math.atan2(cy, cx);
                
                const hx = (R - r) * Math.cos(t) + r * Math.cos((R - r) / r * t);
                const hy = (R - r) * Math.sin(t) - r * Math.sin((R - r) / r * t);
                
                const dist = Math.sqrt((cx - hx) * (cx - hx) + (cy - hy) * (cy - hy));
                return Math.floor(this.maxIterations * Math.exp(-dist * 3));
            }
            
            fermat(x, y) {
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                const r = Math.sqrt(cx * cx + cy * cy);
                const theta = Math.atan2(cy, cx);
                
                // Fermat spiral: rÂ² = aÂ² * theta
                const a = 0.5;
                const fermatR = a * Math.sqrt(Math.abs(theta));
                const diff = Math.abs(r - fermatR);
                
                return Math.floor(this.maxIterations * Math.exp(-diff * 8));
            }
            
            calculatePoint(x, y) {
                const cx = (x - this.width / 2) / this.zoom + this.centerX;
                const cy = (y - this.height / 2) / this.zoom + this.centerY;
                
                switch(this.fractalType) {
                    case 'mandelbrot1': return this.mandelbrot(cx, cy, 1);
                    case 'mandelbrot2': return this.mandelbrot(cx, cy, 2);
                    case 'mandelbrot3': return this.mandelbrot(cx, cy, 3);
                    case 'mandelbrot4': return this.mandelbrot(cx, cy, 4);
                    case 'mandelbrot-2': return this.mandelbrot(cx, cy, -2);
                    case 'burningship': return this.burningShip(cx, cy);
                    case 'julia': return this.julia(cx, cy);
                    case 'phoenix': return this.phoenix(cx, cy);
                    case 'newton': return this.newton(cx, cy);
                    case 'tricorn': return this.tricorn(cx, cy);
                    case 'multibrot': return this.multibrot(cx, cy);
                    case 'dragon': return this.dragon(x, y);
                    case 'spiral': return this.spiral(x, y);
                    case 'rose': return this.rose(x, y);
                    case 'lissajous': return this.lissajous(x, y);
                    case 'hypocycloid': return this.hypocycloid(x, y);
                    case 'fermat': return this.fermat(x, y);
                    default: return this.mandelbrot(cx, cy, 2);
                }
            }
            
            render() {
                document.getElementById('loading').style.display = 'block';
                
                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    const imageData = this.ctx.createImageData(this.width, this.height);
                    const data = imageData.data;
                    
                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            const iterations = this.calculatePoint(x, y);
                            const [r, g, b] = this.getColor(iterations);
                            
                            const index = (y * this.width + x) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 255;
                        }
                    }
                    
                    this.ctx.putImageData(imageData, 0, 0);
                    this.updateCoordinates();
                    document.getElementById('loading').style.display = 'none';
                }, 10);
            }
        }
        
        // Initialize the fractal renderer
        window.addEventListener('load', () => {
            new FractalRenderer();
        });
    </script>
</body>
</html>
